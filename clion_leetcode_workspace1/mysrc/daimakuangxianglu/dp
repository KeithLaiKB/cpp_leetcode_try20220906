1. 定义数组dp[] 或者dp[][]
2. 弄出状态转移 也就是推导公式
    例如
        dp[i][j]=dp[i+1][j-1]+2
        或者 带有max 或者min的状态转移
        dp[i][j]=max( dp[i][j-1] , dp[i+1][j]   )
3. 初始化
        注意 不是所有都只需要初始化 dp[0][0]=0 类似这种东西的
        有可能是需要 批量 初始化多个
        例如
            for(i=0;i<=s.size()-1;i++){
                dp[i][i]=1;
            }

4.设置遍历顺序
    例如dp[i][j]这种二位数组
        他有可能是 从下到上, 从左到右去遍历的
        而有可能不是 传统的 从上到下 从左到右 遍历

5.打印结果
    进行复核



----------------------
t121股票一
    只能买卖一次 同一只股
    dp[i][0] 存放的是买入时的最小值:
        1.之前买入的便宜
        或者
        2.今天买入的便宜:
        因为只对一只股票的 进行 一次买卖, 所以买入是有 -price[i]

        推断式为:
        dp[i][0] = max(dp[i-1][0], -price[i]);


    dp[i][1] 存放的是获得利润的最大值
        1.之前完成了一次买卖 / 还没进行买卖
        或者
        2.该天进行卖(之前买入的最小值 + 当天price[i]) 获得的最大利润

        推断式为:
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+price[i]);





t122股票二
    能多次买卖 同一只股
    dp[i][0] 存放的是 此时 手持股票时, 手上剩余的最大现金数量 :
        1. 之前手持 这唯一的一只股票时 手头剩余的金额
        或者
        2. 之前获利以后利用手上剩余的总现金 再去买: dp[i-1][i]-price[i]

        可以看出: 也就是买入策略的二选一

        推断式为:
        dp[i][0] = max(dp[i-1][0], dp[i-1][i]-price[i]);        //可以看出 这里和上面的t121 股票一 是有区别的



    dp[i][1] 存放的是获得利润的最大值
        1.之前完成了一次或多次买卖 / 还没进行买卖
        或者
        2.该天进行卖(之前 手持股票时 手上剩余的最大现金数量 + 当天price[i]) 获得的最大利润
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+price[i]);

