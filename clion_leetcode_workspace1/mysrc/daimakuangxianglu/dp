1. 定义数组dp[] 或者dp[][]
2. 弄出状态转移 也就是推导公式
    例如
        dp[i][j]=dp[i+1][j-1]+2
        或者 带有max 或者min的状态转移
        dp[i][j]=max( dp[i][j-1] , dp[i+1][j]   )
3. 初始化
        注意 不是所有都只需要初始化 dp[0][0]=0 类似这种东西的
        有可能是需要 批量 初始化多个
        例如
            for(i=0;i<=s.size()-1;i++){
                dp[i][i]=1;
            }

4.设置遍历顺序
    例如dp[i][j]这种二位数组
        他有可能是 从下到上, 从左到右去遍历的
        而有可能不是 传统的 从上到下 从左到右 遍历

5.打印结果
    进行复核



----------------------
t121股票一
    只能买卖一次 同一只股
    dp[i][0] 存放的是 (买入时的最小值时) 此时手上剩余的最大现金数量 :
        1.之前买入的便宜
        或者
        2.今天买入的便宜:
        因为只对一只股票的 进行 一次买卖, 所以买入是有 -price[i]

        注意 这里我并没有提到不买的时候便宜
            也就是说 dp[i][0] 必须是买的情况,
                基本来说 你买 那么dp[i][0] 这整一列都是负数
            这个思想要记住 不然dp[i][1]的推断式子的定义 容易混乱
            所以dp[i][0]要初始化第一天的-price[i], dp[i][1]=0


        推断式为 (求得 持有股票时, 手上最大的现金流方案) :
        dp[i][0] = max(dp[i-1][0], -price[i]);


    dp[i][1] 存放的是 (成本 + 利润) 的最大值
        1.之前完成了一次买卖 / 还没进行买卖
        或者
        2.该天进行卖(之前买入的最小值 + 当天price[i]) 获得的最大利润

        推断式为 :
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+price[i]);
                                    负数 + 卖出价格 = 成本+利润 的总数 (你可以自己琢磨 它不是只是利润的部分)

        简单的说 (成本 + 利润) 的最大值 = (已经完成交易了)当天 不进行 交易
                                        vs
                                      (未完成交易时)当天 进行 交易



t122股票二
    能多次买卖 同一只股
    dp[i][0] 存放的是 此时 手持股票时, 手上剩余的最大现金数量 :
        1. 之前手持 这唯一的一只股票时 手头剩余的金额
        或者
        2. 之前获利以后利用手上剩余的总现金 再去买: dp[i-1][1]-price[i]

        可以看出: 也就是买入策略的二选一

        推断式为 (求得 持有股票时, 手上最大的现金流方案) :
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]-price[i]);        //可以看出 这里和上面的t121 股票一 是不同的



    dp[i][1] 存放的是 此时 不手持股票时, 也就是卖出股票后, 获得 (成本 + 利润) 的最大值
        1.之前完成了一次或多次买卖 / 还没进行买卖
        或者
        2.该天进行卖(之前 手持股票时 手上剩余的最大现金数量 + 当天price[i]) 获得的最大利润
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+price[i]);

        简单的说 (成本 + 利润) 的最大值 = (在已有的现金流上)当天 不进行 交易
                                        vs
                                      (在已有的现金流上)当天 进行 交易
