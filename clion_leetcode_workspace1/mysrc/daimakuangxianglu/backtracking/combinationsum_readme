t77
    就是从[1,n]的范围内, 找出所有 能拼成 元素数量为k的 集合
t216:
    就是 k 个 数字 组成一个 sum=n的 vector<vector<int>>

t17
    一共k个数字, 每个数字代表一个 含有不同字符的集合
    从而 分别从不同集合抽一个字符
        然后将这些结合 进行组合, 每个组合一共k个字符

t39
    根据已有数字的数组, 从中选出 若干个数字, 从而组成集合 从而得到 sum==target
    注意
        每个数字可重复, 但组成的每个集合不能重复

t40
    根据已有数字的数组, 为了得到 sum==target
    从中选出 若干个数字

    注意
        每个idx上的数字不可重复使用, 但组成的每个集合不能重复
        但是 已知原来的输入 是包含重复元素的

    做法1 用used数组, 做法2 用start_index

t78
    输入数组 不会相同
    找出所有子集

t90
    输入数组 可能会相同
    找出所有子集
    我感觉和t40很像, t90是每个节点都要记录

t491
    输入数组 不能被重新排序,并且不能少于两个数字
    找出所有递增的子集
    感觉这个是 t40的升级版, 因为t40它本身是允许 自己排序的

t47
    意义上:
        他是t46基础上 多出了一个前提条件 就是 源数组内有重复元素
        返回的话 跟46差不多 也是要求unique(当然46他本身就是unique的)
        对used数组的进行玩法, 他就是循环used数组
        他是找所有的可能性, 而不需要求和
    写法上:
        当前题和t40的写法基本一样, 除了for循环是 i=0开始 而不是i=layer_index开始
