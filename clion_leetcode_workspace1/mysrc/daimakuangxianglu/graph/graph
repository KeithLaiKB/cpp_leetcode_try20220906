kamacoder98
    邻接矩阵
        vector(n+1,<vector>(n+1))
        初始化的时候 它里面是 0 和 1
            // idx/idx  0    1    2    3    4    5
            //  0       0    0    0    0    0    0
            //  1       0    0    1    1    0    0
            //  2       0    0    0    0    1    0
            //  3       0    0    0    0    0    1
            //  4       0    0    0    0    0    1
            //  5       0    0    0    0    0    0
    邻接表
        1.vector(n+1,<vector>)
        2.vector(n+1,<list>)
        初始化的时候 里面的内容 指的是 目标的位置的idx
            // idx     list(链表)
            //  0
            //  1       2    3
            //  2       4
            //  3       5
            //  4       5
            //  5


------------------------------------------------------------
岛的路径                                                                                        (kamacoder98)       ---邻接矩阵
    1.dfs
    2.bfs
    他们会需要一个direction
        vector<vector<int>> direction= {{-1,0},
                                        {0,1},
                                        {1,0},
                                        {0,-1}};

岛的数量                                                                                        (kamacoder99)       ---邻接矩阵
    base: 岛的路径的代码上
    need: 在最外层for循环的开头,     对没有visited过的且是岛  来 count++

岛的面积                                                                                        (kamacoder100)       ---邻接矩阵
    base: 岛的路径的代码上,
    need: 在最外层for循环的开头,     对没有visited过的且是岛 重头开始算(1或者0 开始)

    可能你一开始觉得是回溯, 但并不是, 因为那个是不能pop的
        例如 kamacoder100
            // 1 1
            // 1 0
            //
            // 这种情况 去用回溯的pop now_area 是不行的
            // 你可以看到这样算法, 他结果其实是2,
            //      就算是 [0,1] 那个地方 他也 到不了[1,0]
            //      因为 还是要从[0,0]出发
            // 然后最外层循环 只要没visited 过都是起始为1或者0起步
            // 因此这种并不是回溯

孤独岛的面积总和                                                                                (kamacoder101)       ---邻接矩阵
    base: 岛的路径的代码上
            (可以不用visited数组, 因为这题目 清0这个操作就类似 visited了)
    need: 最外层for循环 对上下左右边界位置的节点来搜索

    就是通过把沾边的岛 进行搜索清0
    获得处理后的地图
    然后根据 剩下的1 进行累积 得到结果


去掉孤独岛的后的地图                                                                              (kamacoder102)       ---邻接矩阵
    和kamacoder101非常像

    base: 岛的路径的代码上
            (可以不用visited数组, 因为这题目 变2这个操作 还有 不==1 就类似 visited了)
    need: 最外层for循环 对上下左右边界位置的节点来搜索

    就是通过把沾边的岛 进行搜索变2
    获得处理后的地图
    然后根据 剩下的1 清零
    然后根据 剩下的2 变1


能流到上左 下右 两组边界 的peeks (格子)                                                           (kamacoder103)       ---邻接矩阵
    和kamacoder102有点像

    base: 岛的路径的代码上
    need: 最外层for循环 对上左 下右 两组 边界位置的节点来搜索
    通过两组边界
         1. 上左  为边界A, 找出UL 的peeks
         2. 右下  为边界B, 找出DR 的peeks
         然后这两个 Peeks相交 得到的就是 能到双边界的 peeks


把其中哪一个海区域 变成陆地,能够使得 这整副地图中 获得一个最大面积的岛           不建议看, 没什么意义         (kamacoder104)       ---邻接矩阵
    base: 岛的路径的代码上
            (可以不用visited数组, 用岛的id 当作visited就可以了)
    need: 给每个岛都设计编号, 直接把地图中的1 改成 编号 从2开始 (dfs/bfs)
          遍历所有 海水格子 直接 相接壤的岛 (这一步不需要dfs/bfs)



(重点)
计算岛的周长                                                                                   (kamacoder106)       ---邻接矩阵
    1.搜寻每个 陆地格子, 看他上下左右 的格子 是否超过了 边界 或者是海格子
        如果是 则变长+1



(重点)
计算岛的周长                                                                                   (kamacoder110)       ---没有 使用 邻接矩阵/邻接表
    1.搜寻每个 陆地格子, 看他上下左右 的格子 是否超过了 边界 或者是海格子
        如果是 则变长+1

    不是所有的图论都需要 邻接矩阵 和 邻接表的
    我们这里不需要邻接表 和临界矩阵
        因为他并不像 我们前面那样 需要 重复使用 那个 图(邻接矩阵/邻接表)
            来对里面的每个 格子 都去走个 什么dfs/bfs










































