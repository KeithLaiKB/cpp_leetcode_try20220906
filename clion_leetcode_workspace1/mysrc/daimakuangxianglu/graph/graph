kamacoder98
    邻接矩阵
        vector(n+1,<vector>(n+1))
        初始化的时候 它里面是 0 和 1
            // idx/idx  0    1    2    3    4    5
            //  0       0    0    0    0    0    0
            //  1       0    0    1    1    0    0
            //  2       0    0    0    0    1    0
            //  3       0    0    0    0    0    1
            //  4       0    0    0    0    0    1
            //  5       0    0    0    0    0    0
    邻接表
        1.vector(n+1,<vector>)
        2.vector(n+1,<list>)
        初始化的时候 里面的内容 指的是 目标的位置的idx
            // idx     list(链表)
            //  0
            //  1       2    3
            //  2       4
            //  3       5
            //  4       5
            //  5


------------------------------------------------------------
岛的路径(kamacoder98)
    1.dfs
    2.bfs
    他们会需要一个direction
        vector<vector<int>> direction= {{-1,0},
                                        {0,1},
                                        {1,0},
                                        {0,-1}};

岛的数量                                                                        (kamacoder99)
    base: 岛的路径的代码上
    need: 在最外层for循环的开头,     对没有visited过的且是岛  来 count++

岛的面积                                                                        (kamacoder100)
    base: 岛的路径的代码上,
    need: 在最外层for循环的开头,     对没有visited过的且是岛 重头开始算(1或者0 开始)

    可能你一开始觉得是回溯, 但并不是, 因为那个是不能pop的
        例如 kamacoder100
            // 1 1
            // 1 0
            //
            // 这种情况 去用回溯的pop now_area 是不行的
            // 你可以看到这样算法, 他结果其实是2,
            //      就算是 [0,1] 那个地方 他也 到不了[1,0]
            //      因为 还是要从[0,0]出发
            // 然后最外层循环 只要没visited 过都是起始为1或者0起步
            // 因此这种并不是回溯

孤独岛的面积总和                                                                 (kamacoder101)
    base: 岛的路径的代码上
            (可以不用visited数组, 因为这题目 清0这个操作就类似 visited了)
    need: 最外层for循环 对上下左右边界位置的节点来搜索

    就是通过把沾边的岛 进行搜索清0
    获得处理后的地图
    然后根据 剩下的1 进行累积 得到结果


去掉孤独岛的后的地图                                                              (kamacoder102)
    和kamacoder101非常像

    base: 岛的路径的代码上
            (可以不用visited数组, 因为这题目 变2这个操作 还有 不==1 就类似 visited了)
    need: 最外层for循环 对上下左右边界位置的节点来搜索

    就是通过把沾边的岛 进行搜索变2
    获得处理后的地图
    然后根据 剩下的1 清零
    然后根据 剩下的2 变1






