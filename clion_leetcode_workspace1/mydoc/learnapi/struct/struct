做linkedlist的话 用虚拟头节点 删除的时候会方便很多
    例如删除节点的时候, 不需要单独 把head拿出来单独处理,
        因为你要是删了head, 你需要把head重新给 新的head


----------------------------------------------
找环和他的入口,
    于是我们 让slow指针速度是1 快指针速度是2
    x 是 从开始点 走了多少步 到入口点,
    y 是 从入口点 走了多少步 到相撞点,
        注意:相遇的时候一定是fast指针已经走过了一圈 赶上了slow指针
    z 是 从相撞点 走了多少步 能回到 环的入口点

    然后我们有:
    2(x+y) = (x+y) + (y+z)*n
    不会是 2(x+y)*m = (x+y) + (y+z)*n
    不需要乘以m, 因为我们fast指针的速度是2 他一定会在 slow指针 走完一圈内 就撞到了, 不明白的话看代码狂想录的公开视频 会有提到
    所以
    2(x+y) = (x+y) + (y+z)*n
    x+y    =         (y+z)*n
         x = (y+z)*n - y
    由于在画图中 -y 是个负数 是看不出什么东西的 而且y+z 就是一圈
        于是 为了让里面都是 正数
         x = ( (y+z)*(n-1) + (y+z) ) -y
         x = (y+z)*(n-1) + z
    当n = 1 时, 相撞
         x = z
    当n > 1 时, 相撞 也是大概的意思
        他只是说 fast指针转了 很多很多圈 然后遇到了slow指针
        x 仍然是 那个入口点

    于是
    相撞点设置成 index1 指针(不是前面提到的快慢指针了)
        因为
        x = (y+z)*(n-1) + z
        x = z + (y+z)*(n-1)
        这个index1 走个z步 到达入口点 然后不停的转圈

    头节点设置成 index2 指针(不是前面提到的快慢指针了)
        他们同时 移动1位 相遇的时候
        x = z + (y+z)*(n-1)
        因为上面的公式得出
            x值和pos有关 从而得出 入口点


