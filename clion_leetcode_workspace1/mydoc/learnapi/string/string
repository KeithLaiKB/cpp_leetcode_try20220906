
初始化创立:
string 如果不是new 创立的话
    他本身对象实在栈上的
        但是他管理的内容是在堆里的
        string s="hello";
    所以说
    c++中的string(不是new创立的) 的内容是可以变化的
        这个跟 Java中的普通String(不是new创立的) 是不同的
        string* stringp= new string("hello");
-----------------------------------
erase
    当从std::vector中移除元素时，erase函数会将后续的元素向前移动以填补被移除元素的位置。
    这意味着需要在内部进行元素的复制和移动操作，但不会分配额外的内存来存储这些元素,所以
        空间复杂度: O(1)
        时间复杂读: O(n)
-----------------------------------
resize---string 
时间复杂度：
        如果新大小小于当前大小，resize只是截断字符串，不需要分配新内存，因此时间复杂度为 O(1)。
        如果新大小大于当前大小，并且不需要重新分配内存（即当前容量足够），则时间复杂度为 O(n - current_size)，其中 n 是新大小。
            注意我们resize的是大小 而不是 capacity
                也就是说我们的capacity 有可能等于 也有可能大于当前的大小
        如果新大小大于当前大小，并且需要重新分配内存，时间复杂度为 O(n)（旧字符的拷贝）+ O(m)（新字符的初始化），其中 n 是当前大小，m 是新增加的字符数量。因此，总的时间复杂度为 O(n + m)。

空间复杂度：
        如果新大小小于当前大小，不会分配额外内存，空间复杂度为 O(1)。
        如果新大小大于当前大小，并且当前容量足够，则空间复杂度为 O(1)。
        如果新大小大于当前大小，并且需要重新分配内存，空间复杂度为 O(n)，其中 n 是新大小。
            因为t151的结果 肯定是小于等于 当前大小的 所以resize在这题是可以用的


-----------------------------------
substr
    s.substr(st_idx,len);

-----------------------------------
数组 转换成 str

ch[] to str:

    char ch[] = "Hello, C++17!";
    std::string_view sv(ch);

++++++++++++++++++
vector to str:
    vector<char> vec = {'H', 'e', 'l', 'l', 'o'};
    string str(vec.begin(), vec.end());  // 直接用迭代器构造 std::string
-----------------------------------
